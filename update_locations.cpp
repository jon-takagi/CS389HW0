#include <iostream>
#include <assert.h>
#include <stdlib.h>
#include <random>
#include <chrono>
#include <cstdlib>
using data_t = int64_t;

/**
Creates a vector of length size containing random values in the range [-bound,bound)
@param gen      a mersenne_twister_engine used to generate the values
@param size     the length of the vector to create
@param bound    the upper limit for the random values
@return a vector full of random values
*/
std::vector<data_t> generate_random_list(std::mt19937 &gen, int size, int bound) {
    // https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution
    std::uniform_int_distribution<> prng(-1 * bound , bound);
    // std::uniform_real_distribution<> prng(-1 * bound , bound);
    std::vector<data_t> rands(size);
    for (int i = 0; i < size; i++) {
        // Use prng (the uniform_real_distribution) to transform the random unsigned int generated by gen into a
        // double in [-bound, bound). Each call to prng(gen) generates a new random double
        rands[i] = prng(gen);
    }
    return rands;
}
/**
Takes in vectors of x,y,z coordinates and amounts to incrememnt them by.
@param xs   a vector containing x coordinates to be updated
@param ys   a vector containing y coordinates to be updated
@param zs   a vector containing z coordinates to be updated
@param vx   a vector containing the amount to increment the x coordinates by
@param vy   a vector containing the amount to increment the y coordinates by
@param vz   a vector containing the amount to increment the z coordinates by
*/
void update_coords(std::vector<data_t> &xs, std::vector<data_t> &ys, std::vector<data_t> &zs, const std::vector<data_t> &vx, std::vector<data_t> &vy, std::vector<data_t> &vz) {
    for (std::vector<data_t>::size_type i = 0; i < xs.size(); i++) {
        xs[i] = xs[i] + vx[i];
        ys[i] = ys[i] + vy[i];
        zs[i] = zs[i] + vz[i];
    }
}
/**
Calculates the average time to run update_coords for a given size of vector.
The number of iterations is also an input to ensure statistical validity of the result.

@param size     the length of the vectors to use, as a command line argument
@param iters    the number of times to update the vector, as a command line argument
@return         the exit code of the program
*/
int main(int argc, char *argv[]) {
    assert(argc == 3);
// https://www.site.uottawa.ca/~lucia/courses/2131-05/labs/Lab3/CommandLineArguments.html
    int size = atoi(argv[1]);
    std::mt19937 gen(size); //Standard mersenne_twister_engine seeded with size
    int iters = atoi(argv[2]);
    std::vector<data_t> xs = generate_random_list(gen, size, 1000);
    std::vector<data_t> ys = generate_random_list(gen, size, 1000);
    std::vector<data_t> zs = generate_random_list(gen, size, 1000);
    std::vector<data_t> vx = generate_random_list(gen, size, 1);
    std::vector<data_t> vy = generate_random_list(gen, size, 1);
    std::vector<data_t> vz = generate_random_list(gen, size, 1);
    auto t1 = std::chrono::high_resolution_clock::now();
    for(int i = 0; i < iters; i++) {
        update_coords(xs, ys, zs, vx, vy, vz);
    }
    auto t2 = std::chrono::high_resolution_clock::now();
    data_t chksum = 0;
    for (std::vector<data_t>::size_type i = 0; i < xs.size(); i++) {
        chksum += xs[i];
        chksum += ys[i];
        chksum += zs[i];
    }
    // std::cout << chksum << "\n";
    std::chrono::duration<double> elapsed = t2 - t1;
    auto mean = 1000000 * elapsed.count() / (size * iters);
    std::cout << size <<"\t" << mean << "\n";
    return 0;
}
